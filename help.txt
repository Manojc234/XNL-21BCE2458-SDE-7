import React, { useState, useEffect } from "react";
import "bootstrap/dist/css/bootstrap.min.css";
import { Card, Table, Form, Button } from "react-bootstrap";
import {jwtDecode} from "jwt-decode";
import qs from "qs";
import API from "../../axiosInstance";

export default function SubmitApproval({ role }) {
  // safely decode token to get user id (if present)
  const token = localStorage.getItem("jwt");
  let userId = null;
  try {
    if (token) {
      const decoded = jwtDecode(token);
      userId = decoded?.sub ?? null;
    }
  } catch (e) {
    console.warn("Failed to decode JWT", e);
    userId = null;
  }

  const [password, setPassword] = useState("");
  const [batch, setBatch] = useState(null);
  const [comments, setComments] = useState("");

  const getNextBatchUrl = () => {
    if (role === "jrmanager") return "/jr-manager/next-batch";
    if (role === "srmanager") return "/sr-manager/next-batch";
    if (role === "director") return "/director/next-batch";
    return "";
  };

  const getDecisionUrl = () => {
    if (role === "jrmanager") return "/jr-manager/decision";
    if (role === "srmanager") return "/sr-manager/decision";
    if (role === "director") return "/director/decision";
    return "";
  };

  const getUserIdParam = () => {
    if (!userId) return {};
    if (role === "jrmanager") return { jrManagerId: userId };
    if (role === "srmanager") return { srManagerId: userId };
    if (role === "director") return { directorId: userId };
    return {};
  };

  
  useEffect(() => {
    console.log("fetchin");
    if (!role) {
      console.debug("SubmitApproval: role not yet available - skipping fetch");
      return;
    }

    const url = getNextBatchUrl();
    if (!url) {
      console.warn("SubmitApproval: unknown role, can't fetch next batch:", role);
      return;
    }

    const fetchNextBatch = async () => {
      try {
        console.debug("Fetching next batch from", `/api${url}`, "params:", getUserIdParam());
        const res = await API.get(`/api${url}`, {
          params: getUserIdParam(),
        });

        console.debug("fetchNextBatch response:", res.data);

        // backend might return an array or a single object
        if (Array.isArray(res.data)) {
          if (res.data.length > 0) {
            setBatch(res.data[0]); 
            console.log(res.data[0]);// take the first "next" batch
          } else {
            setBatch(null); 
          }
        } else if (res.data) {
          setBatch(res.data);
          console.log(res.data);
        } else {
          setBatch(null);
        }
      } catch (err) {
        console.error("Error fetching batch:", err);
        alert("Failed to fetch batch!");
      }
    };
   // console.log(res.data);
    fetchNextBatch();
  }, [role]); 

  const handleDecision = async (approved) => {
    const url = getDecisionUrl();
    if (!url) {
      alert("Unknown role, cannot submit decision!");
      return;
    }

    if (!batch) {
      alert("No batch loaded to submit decision for.");
      return;
    }

    try {
      await API.post(
        `/api${url}`,
        null, // no body
        {
          params: {
            batchIds: [batch.batchId],
            approved,
            password,
            comment: comments,
            ...getUserIdParam(),
          },
          paramsSerializer: (params) => qs.stringify(params, { arrayFormat: "repeat" }),
        }
      );
      alert("Batch submitted successfully!");
      setBatch(null);
      setComments("");
      setPassword("");
    } catch (err) {
      console.error("Error submitting decision:", err);
      alert("Failed to submit decision!");
    }
  };

  if (!batch) return <div className="text-center mt-5">No pending batches.</div>;

  return (
    <div className="container mt-4">
      {/* Batch Information */}
      <Card className="mb-3 shadow-sm">
        <Card.Header className="bg-primary text-white">Batch Information</Card.Header>
        <Card.Body>
          <Table striped bordered hover responsive>
            <tbody>
              <tr><th>Reference</th><td>{batch.yourRef}</td></tr>
              <tr><th>Name</th><td>{batch.batchName}</td></tr>
              <tr><th>Currency</th><td>{batch.currency}</td></tr>
              <tr><th>Status</th><td>{batch.status}</td></tr>
              <tr><th>Payment Ref</th><td>{batch.paymentRef}</td></tr>
            </tbody>
          </Table>
        </Card.Body>
      </Card>

      {/* Batch Summary */}
      <Card className="mb-3 shadow-sm">
        <Card.Header className="bg-primary text-white">Batch Summary</Card.Header>
        <Card.Body>
          <Table striped bordered hover responsive>
            <thead>
              <tr>
                <th>Source Account ID</th>
                <th>Comments</th>
                <th># Payments</th>
                <th>Amount</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>{batch.sourceAccId}</td>
                <td>{batch.comments}</td>
                <td>{batch.numOfPayments}</td>
                <td>{batch.totAmt}</td>
              </tr>
            </tbody>
          </Table>
        </Card.Body>
      </Card>

      {/* Approval Form */}
      <Card className="mb-3 shadow-sm">
        <Card.Header className="bg-primary text-white">Approval Details</Card.Header>
        <Card.Body>
          <Form>
            <Form.Group className="mb-2">
              <Form.Label>Comments (optional)</Form.Label>
              <Form.Control
                as="textarea"
                rows={2}
                value={comments}
                onChange={(e) => setComments(e.target.value)}
              />
            </Form.Group>
            <Form.Group className="mb-2">
              <Form.Label>Password</Form.Label>
              <Form.Control
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Enter your Password"
              />
            </Form.Group>
          </Form>
        </Card.Body>
      </Card>

      {/* Buttons */}
      <div className="d-flex justify-content-end gap-2 mb-4">
        <Button variant="success" onClick={() => handleDecision(true)} disabled={!password}>
          Approve
        </Button>
        <Button variant="danger" onClick={() => handleDecision(false)} disabled={!password}>
          Reject
        </Button>
      </div>
    </div>
  );
}

import axios from "axios";

const API = axios.create({
  baseURL: "http://localhost:8081", 
});


API.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("jwt"); 
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

export default API; 

import React, { useState, useEffect } from "react";
import { Table, Form, Button, Card } from "react-bootstrap";

import API from "../axiosInstance";

export default function BatchTable({ batches, setBatches}) {
  const [selected, setSelected] = useState([]);

  useEffect(() => {
    API
      .get("/api/approver/batches"

      )
      .then((res) => setBatches(res.data))
      .catch((err) => console.error("Error fetching batches:", err));
  }, [setBatches]); //no prob can be empty will run once

  const toggleSelect = (id) => {
    setSelected((prev) =>
      prev.includes(id) ? prev.filter((i) => i !== id) : [...prev, id] //select all ids or add new id to end
    );
  };

  const handleDecision = async (approved) => {

    if (!selected.length) return;

    const action = approved ? "approve" : "reject";
    const confirmAction = window.confirm(
      `Are you sure you want to ${action} batches: ${selected.join(", ")}?`
    );
    if (!confirmAction) return;

    const approverId = 1;

    try {
      await API.post(
        "/api/approver/decision",
        null,
        {
          params: {
            batchIds: selected.join(","),
            approverId: approverId,
            approved: approved,
          },

        }
      );

      alert(`${approved ? "✅ Approved" : "❌ Rejected"} batches successfully!`);
      setBatches((prev) => prev.filter((b) => !selected.includes(b.batchId)));
      setSelected([]);
    } catch (err) {
      console.error("Error submitting decision:", err);
      alert("Failed to update batches");
    }
  };

  return (
    <Card className="p-3">
      <h4>Pending Batches</h4>
      <Table striped bordered hover responsive>
        <thead>
          <tr>
            <th>Select</th>
            <th>Batch Reference</th>
            <th>Name</th>
            <th># Payments</th>
            <th>Amount</th>
            <th>Currency</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          {batches.map((batch) => (  // unique id, stable rendering
            <tr key={batch.batchId}> 
              <td>
                <Form.Check
                  type="checkbox"
                  checked={selected.includes(batch.batchId)}
                  onChange={() => toggleSelect(batch.batchId)}
                />
              </td>
              <td>{batch.yourRef}</td>
              <td>{batch.batchName}</td>
              <td>{batch.numOfPayments}</td>
              <td>₹{batch.totAmt}</td>
              <td>{batch.currency}</td>
              <td>{batch.status}</td>
            </tr>
          ))}
        </tbody>
      </Table>

      <Button
        variant="success"
        onClick={() => handleDecision(true)}
        disabled={!selected.length}
       
      >
        Approve
      </Button>
      <Button
        variant="danger"
        onClick={() => handleDecision(false)}
        disabled={!selected.length}
      >
        Reject
      </Button>
    </Card>
  );
}
